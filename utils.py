{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "b438a355-42bb-4563-834f-f658c02e6405",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Requirement already satisfied: pyreadstat in c:\\users\\temeb\\anaconda3\\lib\\site-packages (1.3.2)\n",
      "Requirement already satisfied: narwhals>=2.0 in c:\\users\\temeb\\anaconda3\\lib\\site-packages (from pyreadstat) (2.12.0)\n",
      "Requirement already satisfied: numpy in c:\\users\\temeb\\anaconda3\\lib\\site-packages (from pyreadstat) (1.26.4)\n",
      "Collecting pdfplumber\n",
      "  Downloading pdfplumber-0.11.8-py3-none-any.whl.metadata (43 kB)\n",
      "Collecting pdfminer.six==20251107 (from pdfplumber)\n",
      "  Downloading pdfminer_six-20251107-py3-none-any.whl.metadata (4.2 kB)\n",
      "Requirement already satisfied: Pillow>=9.1 in c:\\users\\temeb\\anaconda3\\lib\\site-packages (from pdfplumber) (10.4.0)\n",
      "Collecting pypdfium2>=4.18.0 (from pdfplumber)\n",
      "  Downloading pypdfium2-5.0.0-py3-none-win_amd64.whl.metadata (67 kB)\n",
      "Requirement already satisfied: charset-normalizer>=2.0.0 in c:\\users\\temeb\\anaconda3\\lib\\site-packages (from pdfminer.six==20251107->pdfplumber) (3.3.2)\n",
      "Requirement already satisfied: cryptography>=36.0.0 in c:\\users\\temeb\\anaconda3\\lib\\site-packages (from pdfminer.six==20251107->pdfplumber) (43.0.0)\n",
      "Requirement already satisfied: cffi>=1.12 in c:\\users\\temeb\\anaconda3\\lib\\site-packages (from cryptography>=36.0.0->pdfminer.six==20251107->pdfplumber) (1.17.1)\n",
      "Requirement already satisfied: pycparser in c:\\users\\temeb\\anaconda3\\lib\\site-packages (from cffi>=1.12->cryptography>=36.0.0->pdfminer.six==20251107->pdfplumber) (2.21)\n",
      "Downloading pdfplumber-0.11.8-py3-none-any.whl (60 kB)\n",
      "Downloading pdfminer_six-20251107-py3-none-any.whl (5.6 MB)\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   ---------------------------------------- 0.0/5.6 MB ? eta -:--:--\n",
      "   - -------------------------------------- 0.3/5.6 MB ? eta -:--:--\n",
      "   ----- ---------------------------------- 0.8/5.6 MB 2.2 MB/s eta 0:00:03\n",
      "   ------------------ --------------------- 2.6/5.6 MB 5.2 MB/s eta 0:00:01\n",
      "   ---------------------------------------- 5.6/5.6 MB 8.2 MB/s eta 0:00:00\n",
      "Downloading pypdfium2-5.0.0-py3-none-win_amd64.whl (3.1 MB)\n",
      "   ---------------------------------------- 0.0/3.1 MB ? eta -:--:--\n",
      "   ---------------------------------------- 3.1/3.1 MB 35.8 MB/s eta 0:00:00\n",
      "Installing collected packages: pypdfium2, pdfminer.six, pdfplumber\n",
      "Successfully installed pdfminer.six-20251107 pdfplumber-0.11.8 pypdfium2-5.0.0\n"
     ]
    }
   ],
   "source": [
    "# utils.py\n",
    "\n",
    "# Install the missing package\n",
    "import sys\n",
    "!{sys.executable} -m pip install pyreadstat\n",
    "!pip install pdfplumber\n",
    "# Now import the required modules\n",
    "import pdfplumber\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "# Add any other imports your code needs\n",
    "\n",
    "import pyreadstat\n",
    "import io\n",
    "import tempfile\n",
    "import os\n",
    "\n",
    "# PDF handling choices: try tabula (Java), fallback to pdfplumber (pure python but less structured)\n",
    "try:\n",
    "    import tabula\n",
    "    _HAS_TABULA = True\n",
    "except Exception:\n",
    "    _HAS_TABULA = False\n",
    "\n",
    "try:\n",
    "    import pdfplumber\n",
    "    _HAS_PDFPLUMBER = True\n",
    "except Exception:\n",
    "    _HAS_PDFPLUMBER = False\n",
    "\n",
    "\n",
    "def load_file_to_df(uploaded_file):\n",
    "    \"\"\"Return (df, message). uploaded_file is a Streamlit UploadedFile-like object.\"\"\"\n",
    "    name = uploaded_file.name.lower()\n",
    "    try:\n",
    "        if name.endswith('.csv'):\n",
    "            df = pd.read_csv(uploaded_file)\n",
    "            return df, f'CSV loaded ({uploaded_file.name})'\n",
    "        if name.endswith(('.xls', '.xlsx')):\n",
    "            df = pd.read_excel(uploaded_file)\n",
    "            return df, f'Excel loaded ({uploaded_file.name})'\n",
    "        if name.endswith('.dta'):\n",
    "            df, meta = pyreadstat.read_dta(uploaded_file)\n",
    "            return df, f'Stata (.dta) loaded ({uploaded_file.name})'\n",
    "        if name.endswith('.sav'):\n",
    "            df, meta = pyreadstat.read_sav(uploaded_file)\n",
    "            return df, f'SPSS (.sav) loaded ({uploaded_file.name})'\n",
    "        if name.endswith('.pdf'):\n",
    "            # try tabula first\n",
    "            if _HAS_TABULA:\n",
    "                # tabula requires a file path\n",
    "                with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as tmp:\n",
    "                    tmp.write(uploaded_file.read())\n",
    "                    tmp.flush()\n",
    "                    try:\n",
    "                        tables = tabula.read_pdf(tmp.name, pages='all', multiple_tables=True)\n",
    "                        if len(tables) > 0:\n",
    "                            df = pd.concat(tables, ignore_index=True)\n",
    "                            os.unlink(tmp.name)\n",
    "                            return df, f'PDF tables read with tabula ({uploaded_file.name})'\n",
    "                    except Exception as e:\n",
    "                        pass\n",
    "                    finally:\n",
    "                        if os.path.exists(tmp.name):\n",
    "                            os.unlink(tmp.name)\n",
    "            # fallback to pdfplumber\n",
    "            if _HAS_PDFPLUMBER:\n",
    "                uploaded_file.seek(0)\n",
    "                with pdfplumber.open(uploaded_file) as pdf:\n",
    "                    all_tables = []\n",
    "                    for page in pdf.pages:\n",
    "                        try:\n",
    "                            tab = page.extract_table()\n",
    "                            if tab:\n",
    "                                df = pd.DataFrame(tab[1:], columns=tab[0])\n",
    "                                all_tables.append(df)\n",
    "                        except Exception:\n",
    "                            continue\n",
    "                    if all_tables:\n",
    "                        df = pd.concat(all_tables, ignore_index=True)\n",
    "                        return df, f'PDF tables read with pdfplumber ({uploaded_file.name})'\n",
    "            return None, 'Could not extract tables from PDF. Consider exporting tables to CSV/Excel if possible.'\n",
    "    except Exception as e:\n",
    "        return None, f'Error reading file: {e}'\n",
    "\n",
    "\n",
    "def infer_food_columns(df):\n",
    "    \"\"\"A heuristic to suggest likely food/consumption columns (binary or containing keywords).\"\"\"\n",
    "    keywords = ['food','veg','fruit','milk','meat','egg','beans','cereal','root','tuber','fish','dairy']\n",
    "    candidates = []\n",
    "    for col in df.columns:\n",
    "        col_l = str(col).lower()\n",
    "        if any(k in col_l for k in keywords):\n",
    "            candidates.append(col)\n",
    "        else:\n",
    "            # numeric and mostly 0/1 or small integer values\n",
    "            if pd.api.types.is_numeric_dtype(df[col]):\n",
    "                unique = df[col].dropna().unique()[:10]\n",
    "                if all(x in [0,1] or (isinstance(x,(int,np.integer)) and x<=10) for x in unique):\n",
    "                    candidates.append(col)\n",
    "    return candidates\n",
    "\n",
    "\n",
    "def compute_dds(df, food_cols):\n",
    "    \"\"\"Compute a simple DDS: count of positive (>=1) responses across selected food columns.\"\"\"\n",
    "    sub = df[food_cols].copy()\n",
    "    # coerce to numeric then treat >0 as consumed\n",
    "    for c in sub.columns:\n",
    "        sub[c] = pd.to_numeric(sub[c], errors='coerce').fillna(0)\n",
    "    dds = (sub > 0).sum(axis=1)\n",
    "    return dds\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ad540185-a6f5-4ac0-993d-941875d06624",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
